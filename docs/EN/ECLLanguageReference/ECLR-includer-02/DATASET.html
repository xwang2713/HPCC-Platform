<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>DATASET</title><link rel="stylesheet" href="LN-html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="ECL Language Reference"><link rel="up" href="Record_Structures_and_Files.html" title="Record Structures and Files"><link rel="prev" href="XPATH_Support.html" title="XPATH Support"><link rel="next" href="THOR-FLAT_Files.html" title="THOR/FLAT Files"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">DATASET</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="XPATH_Support.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><th width="60%" align="center"><span class="bold"><strong>Record Structures and Files</strong></span></th><td width="20%" align="right">&nbsp;<a accesskey="n" href="THOR-FLAT_Files.html"><img src="images/next.gif" alt="Next"></a></td></tr></table><hr></div><div class="sect1" title="DATASET"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="DATASET"></a>DATASET<a class="indexterm" name="d0e4462"></a></h2></div></div></div><p><span class="emphasis"><em>attr</em></span><span class="bold"><strong> := DATASET(</strong></span><span class="emphasis"><em> file, struct, filetype </em></span><span class="bold"><strong>[,LOOKUP]);</strong></span></p><p><span class="emphasis"><em>attr</em></span><span class="bold"><strong> := DATASET(</strong></span><span class="emphasis"><em> dataset, file, filetype </em></span><span class="bold"><strong>[,LOOKUP]);</strong></span></p><p><span class="emphasis"><em>attr</em></span><span class="bold"><strong> := DATASET(</strong></span><span class="emphasis"><em> </em></span><span class="bold"><strong>WORKUNIT<a class="indexterm" name="d0e4492"></a>( </strong></span>[ <span class="emphasis"><em>wuid ,</em></span> ]<span class="emphasis"><em> namedoutput </em></span><span class="bold"><strong>)</strong></span><span class="emphasis"><em>, struct </em></span><span class="bold"><strong>);</strong></span></p><p><span class="bold"><strong>[ </strong></span><span class="emphasis"><em>attr</em></span><span class="bold"><strong> := ] DATASET(</strong></span><span class="emphasis"><em> recordset </em></span><span class="bold"><strong>[</strong></span><span class="emphasis"><em>, recstruct </em></span><span class="bold"><strong>] );</strong></span></p><p><span class="bold"><strong>DATASET(</strong></span><span class="emphasis"><em> row </em></span><span class="bold"><strong>)</strong></span></p><p><span class="bold"><strong>DATASET(</strong></span><span class="emphasis"><em> childstruct </em></span><span class="bold"><strong> [</strong></span><span class="emphasis"><em>, </em></span><span class="bold"><strong>COUNT<a class="indexterm" name="d0e4541"></a>(</strong></span><span class="emphasis"><em> count </em></span><span class="bold"><strong>) | LENGTH<a class="indexterm" name="d0e4549"></a>(</strong></span><span class="emphasis"><em> size </em></span><span class="bold"><strong>) ]</strong></span><span class="bold"><strong> [</strong></span><span class="emphasis"><em>, </em></span><span class="bold"><strong>CHOOSEN<a class="indexterm" name="d0e4563"></a>(</strong></span><span class="emphasis"><em> maxrecs </em></span><span class="bold"><strong>) ] )</strong></span></p><p><span class="bold"><strong>[GROUPED<a class="indexterm" name="d0e4574"></a>] [LINKCOUNTED<a class="indexterm" name="d0e4578"></a>] [STREAMED<a class="indexterm" name="d0e4582"></a>] DATASET<a class="indexterm" name="d0e4586"></a>(</strong></span><span class="emphasis"><em> struct </em></span><span class="bold"><strong>)</strong></span></p><p><span class="bold"><strong>DATASET(</strong></span><span class="emphasis"><em> dict </em></span><span class="bold"><strong>)</strong></span></p><p><span class="bold"><strong>DATASET(</strong></span><span class="emphasis"><em> count, transform </em></span><span class="bold"><strong> [, DISTRIBUTED | LOCAL ] )</strong></span></p><div class="informaltable"><table border="1"><colgroup><col width="21%" align="left"><col width="79%"></colgroup><tbody><tr><td align="left"><span class="emphasis"><em>attr</em></span></td><td>The name of the DATASET for later use in other definitions.</td></tr><tr><td align="left"><span class="emphasis"><em>file</em></span></td><td>A string constant containing the logical file name. See the <span class="emphasis"><em>Scope &amp; Logical Filenames</em></span> section for more on logical filenames.</td></tr><tr><td align="left"><span class="emphasis"><em>struct</em></span></td><td>The RECORD structure defining the layout of the fields. This may use RECORDOF.</td></tr><tr><td align="left"><span class="emphasis"><em>filetype</em></span></td><td>One of the following keywords, optionally followed by relevant options for that specific type of file: THOR /FLAT, CSV, XML, JSON, PIPE. Each of these is discussed in its own section, below.</td></tr><tr><td align="left"><span class="emphasis"><em>dataset</em></span></td><td>A previously-defined DATASET or recordset from which the record layout is derived. This form is primarily used by the BUILD action and is equivalent to: <pre class="programlisting">      ds := DATASET('filename',RECORDOF(anotherdataset), ... )</pre></td></tr><tr><td align="left"><span class="bold"><strong>LOOKUP</strong></span></td><td>Optional. Specifies that the file layout should be looked up at compile time. See <span class="emphasis"><em>File Layout Resolution at Compile Time</em></span> in the <span class="emphasis"><em>Programmer's Guide</em></span> for more details.</td></tr><tr><td align="left"><span class="bold"><strong>WORKUNIT</strong></span></td><td>Specifies the DATASET is the result of an OUTPUT with the NAMED option within the same or another workunit.</td></tr><tr><td align="left"><span class="emphasis"><em>wuid</em></span></td><td>Optional. A string expression that specifies the workunit identifier of the job that produced the NAMED OUTPUT.</td></tr><tr><td align="left"><span class="emphasis"><em>namedoutput</em></span><span class="bold"><strong></strong></span></td><td>A string expression that specifies the name given in the NAMED option.</td></tr><tr><td align="left"><span class="emphasis"><em>recordset</em></span></td><td><p>A set of in-line data records. This can simply name a previously-defined set definition or explicitly use square brackets to indicate an in-line set definition. Within the square brackets records are separated by commas. The records are specified by either:</p><p>1) Using curly braces ({}) to surround the field values for each record. The field values within each record are comma-delimited.</p><p>2) A comma-delimited list of in-line transform functions that produce the data rows. All the transform functions in the list must produce records in the same result format.</p></td></tr><tr><td align="left"><span class="emphasis"><em>recstruct</em></span></td><td>Optional. The RECORD structure of the <span class="emphasis"><em>recordset.</em></span> Omittable <span class="underline">only</span> if the <span class="emphasis"><em>recordset</em></span> parameter is just one record or a list of in-line transform functions.</td></tr><tr><td align="left"><span class="emphasis"><em>row</em></span></td><td>A single data record. This may be a single-record passed parameter, or the ROW or PROJECT function that defines a 1-row dataset.</td></tr><tr><td align="left"><span class="emphasis"><em>childstruct</em></span></td><td>The RECORD structure of the child records being defined. This may use the RECORDOF function.</td></tr><tr><td align="left"><span class="bold"><strong>COUNT</strong></span></td><td>Optional. Specifies the number of child records attached to the parent (for use when interfacing to external file formats).</td></tr><tr><td align="left"><span class="emphasis"><em>count</em></span></td><td>An expression defining the number of child records. This may be a constant or a field in the enclosing RECORD structure (addressed as SELF.<span class="emphasis"><em>fieldname</em></span>).</td></tr><tr><td align="left"><span class="bold"><strong>LENGTH</strong></span></td><td>Optional. Specifies the <span class="emphasis"><em>size</em></span> of the child records attached to the parent (for use when interfacing to external file formats).</td></tr><tr><td align="left"><span class="emphasis"><em>size</em></span></td><td>An expression defining the size of child records. This may be a constant or a field in the enclosing RECORD structure (addressed as SELF.<span class="emphasis"><em>fieldname</em></span>).</td></tr><tr><td align="left"><span class="bold"><strong>CHOOSEN</strong></span></td><td>Optional. Limits the number of child records attached to the parent. This implicitly uses the CHOOSEN function wherever the child dataset is read.</td></tr><tr><td align="left"><span class="emphasis"><em>maxrecs</em></span></td><td>An expression defining the maximum number of child records for a single parent.</td></tr><tr><td align="left"><span class="bold"><strong>GROUPED</strong></span></td><td>Specifies the DATASET being passed has been grouped using the GROUP function.</td></tr><tr><td align="left"><span class="bold"><strong>LINKCOUNTED</strong></span></td><td>Specifies the DATASET being passed or returned uses the link counted format (each row is stored as a separate memory allocation) instead of the default (embedded) format where the rows of a dataset are all stored in a single block of memory. This is primarily for use in BEGINC++ functions or external C++ library functions.</td></tr><tr><td align="left"><span class="bold"><strong>STREAMED</strong></span></td><td>Specifies the DATASET being returned is returned as a pointer to an IRowStream interface (see the eclhelper.hpp include file for the definition).<span class="bold"><strong>Valid only as a return type.</strong></span> This is primarily for use in BEGINC++ functions or external C++ library functions.</td></tr><tr><td align="left"><span class="emphasis"><em>struct</em></span></td><td>The RECORD structure of the dataset field or parameter. This may use the RECORDOF function.</td></tr><tr><td align="left"><span class="emphasis"><em>dict</em></span></td><td>The name of a DICTIONARY definition.</td></tr><tr><td align="left"><span class="emphasis"><em>count</em></span></td><td>An integer expression specifying the number of records to create.</td></tr><tr><td align="left"><span class="emphasis"><em>transform</em></span></td><td>The TRANSFORM function that will create the records. This may take an integer COUNTER parameter.</td></tr><tr><td align="left"><span class="bold"><strong>DISTRIBUTED</strong></span></td><td>Optional. Specifies distributing the created records across all nodes of the cluster. If omitted, all records are created on node 1.</td></tr><tr><td align="left"><span class="bold"><strong>LOCAL</strong></span></td><td>Optional. Specifies records are created on every node.</td></tr></tbody></table></div><p>The <span class="bold"><strong>DATASET</strong></span> declaration defines a file of records, on disk or in memory. The layout of the records is specified by a RECORD structure (the <span class="emphasis"><em>struct</em></span> or <span class="emphasis"><em>recstruct</em></span> parameters described above). The distribution of records across execution nodes is undefined in general, as it depends on how the DATASET came to be (sprayed in from a landing zone or written to disk by an OUTPUT action), the size of the cluster on which it resides, and the size of the cluster on which it is used (to specify distribution requirements for a particular operation, see the DISTRIBUTE function).</p><p>The first two forms are alternatives to each other and either may be used with any of the <span class="emphasis"><em>filetypes</em></span> described below (<span class="bold"><strong>THOR/FLAT, CSV, XML, JSON, PIPE</strong></span>).</p><p>The third form defines the result of an OUTPUT with the NAMED option within the same workunit or the workunit specified by the <span class="emphasis"><em>wuid</em></span> (see <span class="bold"><strong>Named Output DATASETs</strong></span> below).</p><p>The fourth form defines an in-line dataset (see <span class="bold"><strong>In-line DATASETs</strong></span> below).</p><p>The fifth form is only used in an expression context to allow you to in-line a single record dataset (see <span class="bold"><strong>Single-row DATASET Expressions</strong></span> below).</p><p>The sixth form is only used as a value type in a RECORD structure to define a child dataset (see <span class="bold"><strong>Child DATASETs</strong></span> below).</p><p>The seventh form is only used as a value type to pass DATASET parameters<a class="indexterm" name="d0e4863"></a> (see <span class="bold"><strong>DATASET as a Parameter Type </strong></span>below).</p><p>The eighth form is used to define a DICTIONARY as a DATASET (see <span class="bold"><strong>DATASET from DICTIONARY </strong></span>below).</p><p>The ninth form is used to create a DATASET using a TRANSFORM function (see <span class="bold"><strong>DATASET from TRANSFORM</strong></span> below)</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="XPATH_Support.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="Record_Structures_and_Files.html"><img src="images/up.gif" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="THOR-FLAT_Files.html"><img src="images/next.gif" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">XPATH Support&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.gif" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;THOR/FLAT Files</td></tr></table></div></body></html>