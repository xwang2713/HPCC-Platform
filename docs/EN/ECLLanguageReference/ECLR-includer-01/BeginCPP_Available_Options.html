<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Available Options</title><link rel="stylesheet" href="LN-html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="ECL Language Reference"><link rel="up" href="BEGINCplus_Structure.html" title="BEGINC++ Structure"><link rel="prev" href="ECL_to_Cplus_Mapping.html" title="ECL to C++ Mapping"><link rel="next" href="EMBED_Structure.html" title="EMBED Structure"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Available Options</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ECL_to_Cplus_Mapping.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">BEGINC++ Structure</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="EMBED_Structure.html"><img src="images/next.gif" alt="Next"></a></td></tr></table><hr></div><div class="sect2" title="Available Options"><div class="titlepage"><div><div><h3 class="title"><a name="BeginCPP_Available_Options"></a>Available Options</h3></div></div></div><div class="informaltable"><table border="1"><colgroup><col width="21%" align="left"><col width="79%"></colgroup><tbody><tr><td align="left"><span class="bold"><strong>#option pure</strong></span></td><td>By default, embedded C++ functions are assumed to have side-effects, which means the generated code won't be as efficient as it might be since the calls can't be shared. Adding #option pure inside the embedded C++ <span class="emphasis"><em>code</em></span> causes it to be treated as a pure function without side effects.</td></tr><tr><td align="left"><span class="bold"><strong>#option once</strong></span></td><td>Indicates the function has no side effects and is evaluated at query execution time, even if the parameters are constant, allowing the optimizer to make more efficient calls to the function in some cases.</td></tr><tr><td align="left"><span class="bold"><strong>#option action</strong></span></td><td>Indicates side effects, requiring the optimizer to keep all calls to the function.</td></tr><tr><td align="left"><span class="bold"><strong>#body</strong></span></td><td>Delimits the beginning of executable code. All <span class="emphasis"><em>code</em></span> that precedes #body (such as #include) is generated outside the function definition; all code that follows it is generated inside the function definition.</td></tr></tbody></table></div><p>Example:</p><pre class="programlisting">//static int add(int x,int y) {
INTEGER4 add(INTEGER4 x, INTEGER4 y) := BEGINC++
  #option pure
  return x + y;
ENDC++;
         
OUTPUT(add(10,20));
          
//static void reverseString(size32_t &amp; __lenResult,char *  &amp; __result,
// size32_t lenValue,char * value) {
STRING reverseString(STRING value) := BEGINC++
   size32_t len = lenValue;
   char * out = (char *)rtlMalloc(len);
   for (unsigned i= 0; i &lt; len; i++)
        out[i] = value[len-1-i];
   __lenResult = len;
   __result = out;
ENDC++;
OUTPUT(reverseString('Kevin'));
// This is a function returning an unknown length string via the
// special reference parameters __lenResult and  __result
         
//this function demonstrates #body, allowing #include to be  used
BOOLEAN nocaseInList(STRING search,
          SET OF STRING values) := BEGINC++
#include &lt;string.h&gt;
#body 
  if (isAllValues)
    return true; 
  const byte * cur = (const byte *)values; 
  const byte * end = cur + lenValues; 
  while (cur != end) 
  { 
  unsigned len = *(unsigned *)cur; 
  cur += sizeof(unsigned); 
  if (lenSearch == len &amp;&amp; memicmp(search, cur, len) == 0) 
      return true; 
  cur += len; 
  } 
  return false;
ENDC++;
          
//and another example, generating a variable number of Xes
STRING buildString(INTEGER4 value) := BEGINC++
   char * out = (char *)rtlMalloc(value);
   for (unsigned i= 0; i &lt; value; i++)
     out[i] = 'X';
     __lenResult = value;
     __result = out;
ENDC++;

//examples of embedded, LINKCOUNTED, and STREAMED DATASETs
inRec := { unsigned id };
doneRec := { unsigned4 execid };
out1rec := { unsigned id; };
out2rec := { real id; };

DATASET(doneRec) doSomethingNasty(DATASET(inRec) input) := BEGINC++
  __lenResult = 4;
  __result = rtlMalloc(8);
  *(unsigned *)__result = 91823;
ENDC++;

DATASET(out1Rec) extractResult1(doneRec done) := BEGINC++
   const unsigned id = *(unsigned *)done;
   const unsigned cnt = 10;
   __lenResult = cnt * sizeof(unsigned __int64);
   __result = rtlMalloc(__lenResult);
   for (unsigned i=0; i &lt; cnt; i++)
       ((unsigned __int64 *)__result)[i] = id + i + 1;
ENDC++;

LINKCOUNTED DATASET(out2Rec) extractResult2(doneRec done) := BEGINC++
   const unsigned id = *(unsigned *)done;   
   const unsigned cnt = 10;
   __countResult = cnt;
   __result = _resultAllocator-&gt;createRowset(cnt);
   for (unsigned i=0; i &lt; cnt; i++)
   {
       size32_t allocSize;
        void * row = _resultAllocator-&gt;createRow(allocSize);
        *(double *)row = id + i + 1;
        __result[i] =  (byte *)_resultAllocator-&gt;finalizeRow(allocSize, row, allocSize);
   }
ENDC++;

STREAMED DATASET(out1Rec) extractResult3(doneRec done) := BEGINC++
   class myStream : public IRowStream, public RtlCInterface
   {
    public:
        myStream(IEngineRowAllocator * _allocator, unsigned _id) : allocator(_allocator), id(_id), idx(0) {}
        RTLIMPLEMENT_IINTERFACE

        virtual const void *nextRow()
        {
            if (idx &gt;= 10)
               return NULL;
            size32_t allocSize;
            void * row = allocator-&gt;createRow(allocSize);
            *(unsigned __int64 *)row = id + ++idx;
            return allocator-&gt;finalizeRow(allocSize, row, allocSize);
        }
        virtual void stop() {}
    private:
        unsigned id;
        unsigned idx;
        Linked&lt;IEngineRowAllocator&gt; allocator;
    };
    #body
    const unsigned id = *(unsigned *)done;
    return new myStream(_resultAllocator, id);
ENDC++;

ds := DATASET([1,2,3,4], inRec);

processed := doSomethingNasty(ds);

out1 := NORMALIZE(processed, extractResult1(LEFT), TRANSFORM(RIGHT));
out2 := NORMALIZE(processed, extractResult2(LEFT), TRANSFORM(RIGHT));
out3 := NORMALIZE(processed, extractResult3(LEFT), TRANSFORM(RIGHT));

SEQUENTIAL(OUTPUT(out1),OUTPUT(out2),OUTPUT(out3));
</pre><p>See Also: <a class="link" href="External_Service_Implementation.html" title="External Service Implementation">External Service Implementation</a>, <a class="link" href="EMBED_Structure.html" title="EMBED Structure">EMBED Structure</a></p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ECL_to_Cplus_Mapping.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="BEGINCplus_Structure.html"><img src="images/up.gif" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="EMBED_Structure.html"><img src="images/next.gif" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">ECL to C++ Mapping&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.gif" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;EMBED Structure</td></tr></table></div></body></html>